{"ast":null,"code":"import { copyConfig } from '../moment/constructor';\nimport { configFromStringAndFormat } from './from-string-and-format';\nimport getParsingFlags from './parsing-flags';\nimport { isValid } from './valid';\nimport extend from '../utils/extend'; // date from string and array of format strings\n\nexport function configFromStringAndArray(config) {\n  var tempConfig,\n      bestMoment,\n      scoreToBeat,\n      i,\n      currentScore,\n      validFormatFound,\n      bestFormatIsValid = false;\n\n  if (config._f.length === 0) {\n    getParsingFlags(config).invalidFormat = true;\n    config._d = new Date(NaN);\n    return;\n  }\n\n  for (i = 0; i < config._f.length; i++) {\n    currentScore = 0;\n    validFormatFound = false;\n    tempConfig = copyConfig({}, config);\n\n    if (config._useUTC != null) {\n      tempConfig._useUTC = config._useUTC;\n    }\n\n    tempConfig._f = config._f[i];\n    configFromStringAndFormat(tempConfig);\n\n    if (isValid(tempConfig)) {\n      validFormatFound = true;\n    } // if there is any input that was not parsed add a penalty for that format\n\n\n    currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens\n\n    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n    getParsingFlags(tempConfig).score = currentScore;\n\n    if (!bestFormatIsValid) {\n      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {\n        scoreToBeat = currentScore;\n        bestMoment = tempConfig;\n\n        if (validFormatFound) {\n          bestFormatIsValid = true;\n        }\n      }\n    } else {\n      if (currentScore < scoreToBeat) {\n        scoreToBeat = currentScore;\n        bestMoment = tempConfig;\n      }\n    }\n  }\n\n  extend(config, bestMoment || tempConfig);\n}","map":{"version":3,"sources":["/Users/hahn/Desktop/React/info-retrieval-frontend/node_modules/moment/src/lib/create/from-string-and-array.js"],"names":["copyConfig","configFromStringAndFormat","getParsingFlags","isValid","extend","configFromStringAndArray","config","tempConfig","bestMoment","scoreToBeat","i","currentScore","validFormatFound","bestFormatIsValid","_f","length","invalidFormat","_d","Date","NaN","_useUTC","charsLeftOver","unusedTokens","score"],"mappings":"AAAA,SAASA,UAAT,QAA2B,uBAA3B;AACA,SAASC,yBAAT,QAA0C,0BAA1C;AACA,OAAOC,eAAP,MAA4B,iBAA5B;AACA,SAASC,OAAT,QAAwB,SAAxB;AACA,OAAOC,MAAP,MAAmB,iBAAnB,C,CAEA;;AACA,OAAO,SAASC,wBAAT,CAAkCC,MAAlC,EAA0C;AAC7C,MAAIC,UAAJ;AAAA,MACIC,UADJ;AAAA,MAEIC,WAFJ;AAAA,MAGIC,CAHJ;AAAA,MAIIC,YAJJ;AAAA,MAKIC,gBALJ;AAAA,MAMIC,iBAAiB,GAAG,KANxB;;AAQA,MAAIP,MAAM,CAACQ,EAAP,CAAUC,MAAV,KAAqB,CAAzB,EAA4B;AACxBb,IAAAA,eAAe,CAACI,MAAD,CAAf,CAAwBU,aAAxB,GAAwC,IAAxC;AACAV,IAAAA,MAAM,CAACW,EAAP,GAAY,IAAIC,IAAJ,CAASC,GAAT,CAAZ;AACA;AACH;;AAED,OAAKT,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGJ,MAAM,CAACQ,EAAP,CAAUC,MAA1B,EAAkCL,CAAC,EAAnC,EAAuC;AACnCC,IAAAA,YAAY,GAAG,CAAf;AACAC,IAAAA,gBAAgB,GAAG,KAAnB;AACAL,IAAAA,UAAU,GAAGP,UAAU,CAAC,EAAD,EAAKM,MAAL,CAAvB;;AACA,QAAIA,MAAM,CAACc,OAAP,IAAkB,IAAtB,EAA4B;AACxBb,MAAAA,UAAU,CAACa,OAAX,GAAqBd,MAAM,CAACc,OAA5B;AACH;;AACDb,IAAAA,UAAU,CAACO,EAAX,GAAgBR,MAAM,CAACQ,EAAP,CAAUJ,CAAV,CAAhB;AACAT,IAAAA,yBAAyB,CAACM,UAAD,CAAzB;;AAEA,QAAIJ,OAAO,CAACI,UAAD,CAAX,EAAyB;AACrBK,MAAAA,gBAAgB,GAAG,IAAnB;AACH,KAZkC,CAcnC;;;AACAD,IAAAA,YAAY,IAAIT,eAAe,CAACK,UAAD,CAAf,CAA4Bc,aAA5C,CAfmC,CAiBnC;;AACAV,IAAAA,YAAY,IAAIT,eAAe,CAACK,UAAD,CAAf,CAA4Be,YAA5B,CAAyCP,MAAzC,GAAkD,EAAlE;AAEAb,IAAAA,eAAe,CAACK,UAAD,CAAf,CAA4BgB,KAA5B,GAAoCZ,YAApC;;AAEA,QAAI,CAACE,iBAAL,EAAwB;AACpB,UACIJ,WAAW,IAAI,IAAf,IACAE,YAAY,GAAGF,WADf,IAEAG,gBAHJ,EAIE;AACEH,QAAAA,WAAW,GAAGE,YAAd;AACAH,QAAAA,UAAU,GAAGD,UAAb;;AACA,YAAIK,gBAAJ,EAAsB;AAClBC,UAAAA,iBAAiB,GAAG,IAApB;AACH;AACJ;AACJ,KAZD,MAYO;AACH,UAAIF,YAAY,GAAGF,WAAnB,EAAgC;AAC5BA,QAAAA,WAAW,GAAGE,YAAd;AACAH,QAAAA,UAAU,GAAGD,UAAb;AACH;AACJ;AACJ;;AAEDH,EAAAA,MAAM,CAACE,MAAD,EAASE,UAAU,IAAID,UAAvB,CAAN;AACH","sourcesContent":["import { copyConfig } from '../moment/constructor';\nimport { configFromStringAndFormat } from './from-string-and-format';\nimport getParsingFlags from './parsing-flags';\nimport { isValid } from './valid';\nimport extend from '../utils/extend';\n\n// date from string and array of format strings\nexport function configFromStringAndArray(config) {\n    var tempConfig,\n        bestMoment,\n        scoreToBeat,\n        i,\n        currentScore,\n        validFormatFound,\n        bestFormatIsValid = false;\n\n    if (config._f.length === 0) {\n        getParsingFlags(config).invalidFormat = true;\n        config._d = new Date(NaN);\n        return;\n    }\n\n    for (i = 0; i < config._f.length; i++) {\n        currentScore = 0;\n        validFormatFound = false;\n        tempConfig = copyConfig({}, config);\n        if (config._useUTC != null) {\n            tempConfig._useUTC = config._useUTC;\n        }\n        tempConfig._f = config._f[i];\n        configFromStringAndFormat(tempConfig);\n\n        if (isValid(tempConfig)) {\n            validFormatFound = true;\n        }\n\n        // if there is any input that was not parsed add a penalty for that format\n        currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n        //or tokens\n        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n        getParsingFlags(tempConfig).score = currentScore;\n\n        if (!bestFormatIsValid) {\n            if (\n                scoreToBeat == null ||\n                currentScore < scoreToBeat ||\n                validFormatFound\n            ) {\n                scoreToBeat = currentScore;\n                bestMoment = tempConfig;\n                if (validFormatFound) {\n                    bestFormatIsValid = true;\n                }\n            }\n        } else {\n            if (currentScore < scoreToBeat) {\n                scoreToBeat = currentScore;\n                bestMoment = tempConfig;\n            }\n        }\n    }\n\n    extend(config, bestMoment || tempConfig);\n}\n"]},"metadata":{},"sourceType":"module"}