{"ast":null,"code":"import zeroFill from '../utils/zero-fill';\nimport { createDuration } from '../duration/create';\nimport { addSubtract } from '../moment/add-subtract';\nimport { isMoment, copyConfig } from '../moment/constructor';\nimport { addFormatToken } from '../format/format';\nimport { addRegexToken, matchOffset, matchShortOffset } from '../parse/regex';\nimport { addParseToken } from '../parse/token';\nimport { createLocal } from '../create/local';\nimport { prepareConfig } from '../create/from-anything';\nimport { createUTC } from '../create/utc';\nimport isDate from '../utils/is-date';\nimport toInt from '../utils/to-int';\nimport isUndefined from '../utils/is-undefined';\nimport compareArrays from '../utils/compare-arrays';\nimport { hooks } from '../utils/hooks'; // FORMATTING\n\nfunction offset(token, separator) {\n  addFormatToken(token, 0, 0, function () {\n    var offset = this.utcOffset(),\n        sign = '+';\n\n    if (offset < 0) {\n      offset = -offset;\n      sign = '-';\n    }\n\n    return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);\n  });\n}\n\noffset('Z', ':');\noffset('ZZ', ''); // PARSING\n\naddRegexToken('Z', matchShortOffset);\naddRegexToken('ZZ', matchShortOffset);\naddParseToken(['Z', 'ZZ'], function (input, array, config) {\n  config._useUTC = true;\n  config._tzm = offsetFromString(matchShortOffset, input);\n}); // HELPERS\n// timezone chunker\n// '+10:00' > ['10',  '00']\n// '-1530'  > ['-15', '30']\n\nvar chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\nfunction offsetFromString(matcher, string) {\n  var matches = (string || '').match(matcher),\n      chunk,\n      parts,\n      minutes;\n\n  if (matches === null) {\n    return null;\n  }\n\n  chunk = matches[matches.length - 1] || [];\n  parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n  minutes = +(parts[1] * 60) + toInt(parts[2]);\n  return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;\n} // Return a moment from input, that is local/utc/zone equivalent to model.\n\n\nexport function cloneWithOffset(input, model) {\n  var res, diff;\n\n  if (model._isUTC) {\n    res = model.clone();\n    diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.\n\n    res._d.setTime(res._d.valueOf() + diff);\n\n    hooks.updateOffset(res, false);\n    return res;\n  } else {\n    return createLocal(input).local();\n  }\n}\n\nfunction getDateOffset(m) {\n  // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n  // https://github.com/moment/moment/pull/1871\n  return -Math.round(m._d.getTimezoneOffset());\n} // HOOKS\n// This function will be called whenever a moment is mutated.\n// It is intended to keep the offset in sync with the timezone.\n\n\nhooks.updateOffset = function () {}; // MOMENTS\n// keepLocalTime = true means only change the timezone, without\n// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n// +0200, so we adjust the time as needed, to be valid.\n//\n// Keeping the time actually adds/subtracts (one hour)\n// from the actual represented time. That is why we call updateOffset\n// a second time. In case it wants us to change the offset again\n// _changeInProgress == true case, then we have to adjust, because\n// there is no such time in the given timezone.\n\n\nexport function getSetOffset(input, keepLocalTime, keepMinutes) {\n  var offset = this._offset || 0,\n      localAdjust;\n\n  if (!this.isValid()) {\n    return input != null ? this : NaN;\n  }\n\n  if (input != null) {\n    if (typeof input === 'string') {\n      input = offsetFromString(matchShortOffset, input);\n\n      if (input === null) {\n        return this;\n      }\n    } else if (Math.abs(input) < 16 && !keepMinutes) {\n      input = input * 60;\n    }\n\n    if (!this._isUTC && keepLocalTime) {\n      localAdjust = getDateOffset(this);\n    }\n\n    this._offset = input;\n    this._isUTC = true;\n\n    if (localAdjust != null) {\n      this.add(localAdjust, 'm');\n    }\n\n    if (offset !== input) {\n      if (!keepLocalTime || this._changeInProgress) {\n        addSubtract(this, createDuration(input - offset, 'm'), 1, false);\n      } else if (!this._changeInProgress) {\n        this._changeInProgress = true;\n        hooks.updateOffset(this, true);\n        this._changeInProgress = null;\n      }\n    }\n\n    return this;\n  } else {\n    return this._isUTC ? offset : getDateOffset(this);\n  }\n}\nexport function getSetZone(input, keepLocalTime) {\n  if (input != null) {\n    if (typeof input !== 'string') {\n      input = -input;\n    }\n\n    this.utcOffset(input, keepLocalTime);\n    return this;\n  } else {\n    return -this.utcOffset();\n  }\n}\nexport function setOffsetToUTC(keepLocalTime) {\n  return this.utcOffset(0, keepLocalTime);\n}\nexport function setOffsetToLocal(keepLocalTime) {\n  if (this._isUTC) {\n    this.utcOffset(0, keepLocalTime);\n    this._isUTC = false;\n\n    if (keepLocalTime) {\n      this.subtract(getDateOffset(this), 'm');\n    }\n  }\n\n  return this;\n}\nexport function setOffsetToParsedOffset() {\n  if (this._tzm != null) {\n    this.utcOffset(this._tzm, false, true);\n  } else if (typeof this._i === 'string') {\n    var tZone = offsetFromString(matchOffset, this._i);\n\n    if (tZone != null) {\n      this.utcOffset(tZone);\n    } else {\n      this.utcOffset(0, true);\n    }\n  }\n\n  return this;\n}\nexport function hasAlignedHourOffset(input) {\n  if (!this.isValid()) {\n    return false;\n  }\n\n  input = input ? createLocal(input).utcOffset() : 0;\n  return (this.utcOffset() - input) % 60 === 0;\n}\nexport function isDaylightSavingTime() {\n  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();\n}\nexport function isDaylightSavingTimeShifted() {\n  if (!isUndefined(this._isDSTShifted)) {\n    return this._isDSTShifted;\n  }\n\n  var c = {},\n      other;\n  copyConfig(c, this);\n  c = prepareConfig(c);\n\n  if (c._a) {\n    other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n    this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;\n  } else {\n    this._isDSTShifted = false;\n  }\n\n  return this._isDSTShifted;\n}\nexport function isLocal() {\n  return this.isValid() ? !this._isUTC : false;\n}\nexport function isUtcOffset() {\n  return this.isValid() ? this._isUTC : false;\n}\nexport function isUtc() {\n  return this.isValid() ? this._isUTC && this._offset === 0 : false;\n}","map":{"version":3,"sources":["/Users/hahn/Desktop/React/info-retrieval-frontend/node_modules/moment/src/lib/units/offset.js"],"names":["zeroFill","createDuration","addSubtract","isMoment","copyConfig","addFormatToken","addRegexToken","matchOffset","matchShortOffset","addParseToken","createLocal","prepareConfig","createUTC","isDate","toInt","isUndefined","compareArrays","hooks","offset","token","separator","utcOffset","sign","input","array","config","_useUTC","_tzm","offsetFromString","chunkOffset","matcher","string","matches","match","chunk","parts","minutes","length","cloneWithOffset","model","res","diff","_isUTC","clone","valueOf","_d","setTime","updateOffset","local","getDateOffset","m","Math","round","getTimezoneOffset","getSetOffset","keepLocalTime","keepMinutes","_offset","localAdjust","isValid","NaN","abs","add","_changeInProgress","getSetZone","setOffsetToUTC","setOffsetToLocal","subtract","setOffsetToParsedOffset","_i","tZone","hasAlignedHourOffset","isDaylightSavingTime","month","isDaylightSavingTimeShifted","_isDSTShifted","c","other","_a","toArray","isLocal","isUtcOffset","isUtc"],"mappings":"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","sourcesContent":["import zeroFill from '../utils/zero-fill';\nimport { createDuration } from '../duration/create';\nimport { addSubtract } from '../moment/add-subtract';\nimport { isMoment, copyConfig } from '../moment/constructor';\nimport { addFormatToken } from '../format/format';\nimport { addRegexToken, matchOffset, matchShortOffset } from '../parse/regex';\nimport { addParseToken } from '../parse/token';\nimport { createLocal } from '../create/local';\nimport { prepareConfig } from '../create/from-anything';\nimport { createUTC } from '../create/utc';\nimport isDate from '../utils/is-date';\nimport toInt from '../utils/to-int';\nimport isUndefined from '../utils/is-undefined';\nimport compareArrays from '../utils/compare-arrays';\nimport { hooks } from '../utils/hooks';\n\n// FORMATTING\n\nfunction offset(token, separator) {\n    addFormatToken(token, 0, 0, function () {\n        var offset = this.utcOffset(),\n            sign = '+';\n        if (offset < 0) {\n            offset = -offset;\n            sign = '-';\n        }\n        return (\n            sign +\n            zeroFill(~~(offset / 60), 2) +\n            separator +\n            zeroFill(~~offset % 60, 2)\n        );\n    });\n}\n\noffset('Z', ':');\noffset('ZZ', '');\n\n// PARSING\n\naddRegexToken('Z', matchShortOffset);\naddRegexToken('ZZ', matchShortOffset);\naddParseToken(['Z', 'ZZ'], function (input, array, config) {\n    config._useUTC = true;\n    config._tzm = offsetFromString(matchShortOffset, input);\n});\n\n// HELPERS\n\n// timezone chunker\n// '+10:00' > ['10',  '00']\n// '-1530'  > ['-15', '30']\nvar chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\nfunction offsetFromString(matcher, string) {\n    var matches = (string || '').match(matcher),\n        chunk,\n        parts,\n        minutes;\n\n    if (matches === null) {\n        return null;\n    }\n\n    chunk = matches[matches.length - 1] || [];\n    parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n    minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n    return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;\n}\n\n// Return a moment from input, that is local/utc/zone equivalent to model.\nexport function cloneWithOffset(input, model) {\n    var res, diff;\n    if (model._isUTC) {\n        res = model.clone();\n        diff =\n            (isMoment(input) || isDate(input)\n                ? input.valueOf()\n                : createLocal(input).valueOf()) - res.valueOf();\n        // Use low-level api, because this fn is low-level api.\n        res._d.setTime(res._d.valueOf() + diff);\n        hooks.updateOffset(res, false);\n        return res;\n    } else {\n        return createLocal(input).local();\n    }\n}\n\nfunction getDateOffset(m) {\n    // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n    // https://github.com/moment/moment/pull/1871\n    return -Math.round(m._d.getTimezoneOffset());\n}\n\n// HOOKS\n\n// This function will be called whenever a moment is mutated.\n// It is intended to keep the offset in sync with the timezone.\nhooks.updateOffset = function () {};\n\n// MOMENTS\n\n// keepLocalTime = true means only change the timezone, without\n// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n// +0200, so we adjust the time as needed, to be valid.\n//\n// Keeping the time actually adds/subtracts (one hour)\n// from the actual represented time. That is why we call updateOffset\n// a second time. In case it wants us to change the offset again\n// _changeInProgress == true case, then we have to adjust, because\n// there is no such time in the given timezone.\nexport function getSetOffset(input, keepLocalTime, keepMinutes) {\n    var offset = this._offset || 0,\n        localAdjust;\n    if (!this.isValid()) {\n        return input != null ? this : NaN;\n    }\n    if (input != null) {\n        if (typeof input === 'string') {\n            input = offsetFromString(matchShortOffset, input);\n            if (input === null) {\n                return this;\n            }\n        } else if (Math.abs(input) < 16 && !keepMinutes) {\n            input = input * 60;\n        }\n        if (!this._isUTC && keepLocalTime) {\n            localAdjust = getDateOffset(this);\n        }\n        this._offset = input;\n        this._isUTC = true;\n        if (localAdjust != null) {\n            this.add(localAdjust, 'm');\n        }\n        if (offset !== input) {\n            if (!keepLocalTime || this._changeInProgress) {\n                addSubtract(\n                    this,\n                    createDuration(input - offset, 'm'),\n                    1,\n                    false\n                );\n            } else if (!this._changeInProgress) {\n                this._changeInProgress = true;\n                hooks.updateOffset(this, true);\n                this._changeInProgress = null;\n            }\n        }\n        return this;\n    } else {\n        return this._isUTC ? offset : getDateOffset(this);\n    }\n}\n\nexport function getSetZone(input, keepLocalTime) {\n    if (input != null) {\n        if (typeof input !== 'string') {\n            input = -input;\n        }\n\n        this.utcOffset(input, keepLocalTime);\n\n        return this;\n    } else {\n        return -this.utcOffset();\n    }\n}\n\nexport function setOffsetToUTC(keepLocalTime) {\n    return this.utcOffset(0, keepLocalTime);\n}\n\nexport function setOffsetToLocal(keepLocalTime) {\n    if (this._isUTC) {\n        this.utcOffset(0, keepLocalTime);\n        this._isUTC = false;\n\n        if (keepLocalTime) {\n            this.subtract(getDateOffset(this), 'm');\n        }\n    }\n    return this;\n}\n\nexport function setOffsetToParsedOffset() {\n    if (this._tzm != null) {\n        this.utcOffset(this._tzm, false, true);\n    } else if (typeof this._i === 'string') {\n        var tZone = offsetFromString(matchOffset, this._i);\n        if (tZone != null) {\n            this.utcOffset(tZone);\n        } else {\n            this.utcOffset(0, true);\n        }\n    }\n    return this;\n}\n\nexport function hasAlignedHourOffset(input) {\n    if (!this.isValid()) {\n        return false;\n    }\n    input = input ? createLocal(input).utcOffset() : 0;\n\n    return (this.utcOffset() - input) % 60 === 0;\n}\n\nexport function isDaylightSavingTime() {\n    return (\n        this.utcOffset() > this.clone().month(0).utcOffset() ||\n        this.utcOffset() > this.clone().month(5).utcOffset()\n    );\n}\n\nexport function isDaylightSavingTimeShifted() {\n    if (!isUndefined(this._isDSTShifted)) {\n        return this._isDSTShifted;\n    }\n\n    var c = {},\n        other;\n\n    copyConfig(c, this);\n    c = prepareConfig(c);\n\n    if (c._a) {\n        other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n        this._isDSTShifted =\n            this.isValid() && compareArrays(c._a, other.toArray()) > 0;\n    } else {\n        this._isDSTShifted = false;\n    }\n\n    return this._isDSTShifted;\n}\n\nexport function isLocal() {\n    return this.isValid() ? !this._isUTC : false;\n}\n\nexport function isUtcOffset() {\n    return this.isValid() ? this._isUTC : false;\n}\n\nexport function isUtc() {\n    return this.isValid() ? this._isUTC && this._offset === 0 : false;\n}\n"]},"metadata":{},"sourceType":"module"}