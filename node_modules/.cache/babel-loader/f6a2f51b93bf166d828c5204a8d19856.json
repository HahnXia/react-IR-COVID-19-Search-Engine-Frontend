{"ast":null,"code":"import { configFromISO, configFromRFC2822 } from './from-string';\nimport { configFromArray } from './from-array';\nimport { getParseRegexForToken } from '../parse/regex';\nimport { addTimeToArrayFromToken } from '../parse/token';\nimport { expandFormat, formatTokenFunctions, formattingTokens } from '../format/format';\nimport checkOverflow from './check-overflow';\nimport { YEAR, HOUR } from '../units/constants';\nimport { hooks } from '../utils/hooks';\nimport getParsingFlags from './parsing-flags'; // constant that refers to the ISO standard\n\nhooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form\n\n\nhooks.RFC_2822 = function () {}; // date from string and format string\n\n\nexport function configFromStringAndFormat(config) {\n  // TODO: Move this to another part of the creation flow to prevent circular deps\n  if (config._f === hooks.ISO_8601) {\n    configFromISO(config);\n    return;\n  }\n\n  if (config._f === hooks.RFC_2822) {\n    configFromRFC2822(config);\n    return;\n  }\n\n  config._a = [];\n  getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`\n\n  var string = '' + config._i,\n      i,\n      parsedInput,\n      tokens,\n      token,\n      skipped,\n      stringLength = string.length,\n      totalParsedInputLength = 0,\n      era;\n  tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n  for (i = 0; i < tokens.length; i++) {\n    token = tokens[i];\n    parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]; // console.log('token', token, 'parsedInput', parsedInput,\n    //         'regex', getParseRegexForToken(token, config));\n\n    if (parsedInput) {\n      skipped = string.substr(0, string.indexOf(parsedInput));\n\n      if (skipped.length > 0) {\n        getParsingFlags(config).unusedInput.push(skipped);\n      }\n\n      string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n      totalParsedInputLength += parsedInput.length;\n    } // don't parse if it's not a known token\n\n\n    if (formatTokenFunctions[token]) {\n      if (parsedInput) {\n        getParsingFlags(config).empty = false;\n      } else {\n        getParsingFlags(config).unusedTokens.push(token);\n      }\n\n      addTimeToArrayFromToken(token, parsedInput, config);\n    } else if (config._strict && !parsedInput) {\n      getParsingFlags(config).unusedTokens.push(token);\n    }\n  } // add remaining unparsed input length to the string\n\n\n  getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n\n  if (string.length > 0) {\n    getParsingFlags(config).unusedInput.push(string);\n  } // clear _12h flag if hour is <= 12\n\n\n  if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {\n    getParsingFlags(config).bigHour = undefined;\n  }\n\n  getParsingFlags(config).parsedDateParts = config._a.slice(0);\n  getParsingFlags(config).meridiem = config._meridiem; // handle meridiem\n\n  config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem); // handle era\n\n  era = getParsingFlags(config).era;\n\n  if (era !== null) {\n    config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);\n  }\n\n  configFromArray(config);\n  checkOverflow(config);\n}\n\nfunction meridiemFixWrap(locale, hour, meridiem) {\n  var isPm;\n\n  if (meridiem == null) {\n    // nothing to do\n    return hour;\n  }\n\n  if (locale.meridiemHour != null) {\n    return locale.meridiemHour(hour, meridiem);\n  } else if (locale.isPM != null) {\n    // Fallback\n    isPm = locale.isPM(meridiem);\n\n    if (isPm && hour < 12) {\n      hour += 12;\n    }\n\n    if (!isPm && hour === 12) {\n      hour = 0;\n    }\n\n    return hour;\n  } else {\n    // this is not supposed to happen\n    return hour;\n  }\n}","map":{"version":3,"sources":["/Users/hahn/Desktop/React/info-retrieval-frontend/node_modules/moment/src/lib/create/from-string-and-format.js"],"names":["configFromISO","configFromRFC2822","configFromArray","getParseRegexForToken","addTimeToArrayFromToken","expandFormat","formatTokenFunctions","formattingTokens","checkOverflow","YEAR","HOUR","hooks","getParsingFlags","ISO_8601","RFC_2822","configFromStringAndFormat","config","_f","_a","empty","string","_i","i","parsedInput","tokens","token","skipped","stringLength","length","totalParsedInputLength","era","_locale","match","substr","indexOf","unusedInput","push","slice","unusedTokens","_strict","charsLeftOver","bigHour","undefined","parsedDateParts","meridiem","_meridiem","meridiemFixWrap","erasConvertYear","locale","hour","isPm","meridiemHour","isPM"],"mappings":"AAAA,SAASA,aAAT,EAAwBC,iBAAxB,QAAiD,eAAjD;AACA,SAASC,eAAT,QAAgC,cAAhC;AACA,SAASC,qBAAT,QAAsC,gBAAtC;AACA,SAASC,uBAAT,QAAwC,gBAAxC;AACA,SACIC,YADJ,EAEIC,oBAFJ,EAGIC,gBAHJ,QAIO,kBAJP;AAKA,OAAOC,aAAP,MAA0B,kBAA1B;AACA,SAASC,IAAT,EAAeC,IAAf,QAA2B,oBAA3B;AACA,SAASC,KAAT,QAAsB,gBAAtB;AACA,OAAOC,eAAP,MAA4B,iBAA5B,C,CAEA;;AACAD,KAAK,CAACE,QAAN,GAAiB,YAAY,CAAE,CAA/B,C,CAEA;;;AACAF,KAAK,CAACG,QAAN,GAAiB,YAAY,CAAE,CAA/B,C,CAEA;;;AACA,OAAO,SAASC,yBAAT,CAAmCC,MAAnC,EAA2C;AAC9C;AACA,MAAIA,MAAM,CAACC,EAAP,KAAcN,KAAK,CAACE,QAAxB,EAAkC;AAC9Bb,IAAAA,aAAa,CAACgB,MAAD,CAAb;AACA;AACH;;AACD,MAAIA,MAAM,CAACC,EAAP,KAAcN,KAAK,CAACG,QAAxB,EAAkC;AAC9Bb,IAAAA,iBAAiB,CAACe,MAAD,CAAjB;AACA;AACH;;AACDA,EAAAA,MAAM,CAACE,EAAP,GAAY,EAAZ;AACAN,EAAAA,eAAe,CAACI,MAAD,CAAf,CAAwBG,KAAxB,GAAgC,IAAhC,CAX8C,CAa9C;;AACA,MAAIC,MAAM,GAAG,KAAKJ,MAAM,CAACK,EAAzB;AAAA,MACIC,CADJ;AAAA,MAEIC,WAFJ;AAAA,MAGIC,MAHJ;AAAA,MAIIC,KAJJ;AAAA,MAKIC,OALJ;AAAA,MAMIC,YAAY,GAAGP,MAAM,CAACQ,MAN1B;AAAA,MAOIC,sBAAsB,GAAG,CAP7B;AAAA,MAQIC,GARJ;AAUAN,EAAAA,MAAM,GACFnB,YAAY,CAACW,MAAM,CAACC,EAAR,EAAYD,MAAM,CAACe,OAAnB,CAAZ,CAAwCC,KAAxC,CAA8CzB,gBAA9C,KAAmE,EADvE;;AAGA,OAAKe,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGE,MAAM,CAACI,MAAvB,EAA+BN,CAAC,EAAhC,EAAoC;AAChCG,IAAAA,KAAK,GAAGD,MAAM,CAACF,CAAD,CAAd;AACAC,IAAAA,WAAW,GAAG,CAACH,MAAM,CAACY,KAAP,CAAa7B,qBAAqB,CAACsB,KAAD,EAAQT,MAAR,CAAlC,KACX,EADU,EACN,CADM,CAAd,CAFgC,CAIhC;AACA;;AACA,QAAIO,WAAJ,EAAiB;AACbG,MAAAA,OAAO,GAAGN,MAAM,CAACa,MAAP,CAAc,CAAd,EAAiBb,MAAM,CAACc,OAAP,CAAeX,WAAf,CAAjB,CAAV;;AACA,UAAIG,OAAO,CAACE,MAAR,GAAiB,CAArB,EAAwB;AACpBhB,QAAAA,eAAe,CAACI,MAAD,CAAf,CAAwBmB,WAAxB,CAAoCC,IAApC,CAAyCV,OAAzC;AACH;;AACDN,MAAAA,MAAM,GAAGA,MAAM,CAACiB,KAAP,CACLjB,MAAM,CAACc,OAAP,CAAeX,WAAf,IAA8BA,WAAW,CAACK,MADrC,CAAT;AAGAC,MAAAA,sBAAsB,IAAIN,WAAW,CAACK,MAAtC;AACH,KAf+B,CAgBhC;;;AACA,QAAItB,oBAAoB,CAACmB,KAAD,CAAxB,EAAiC;AAC7B,UAAIF,WAAJ,EAAiB;AACbX,QAAAA,eAAe,CAACI,MAAD,CAAf,CAAwBG,KAAxB,GAAgC,KAAhC;AACH,OAFD,MAEO;AACHP,QAAAA,eAAe,CAACI,MAAD,CAAf,CAAwBsB,YAAxB,CAAqCF,IAArC,CAA0CX,KAA1C;AACH;;AACDrB,MAAAA,uBAAuB,CAACqB,KAAD,EAAQF,WAAR,EAAqBP,MAArB,CAAvB;AACH,KAPD,MAOO,IAAIA,MAAM,CAACuB,OAAP,IAAkB,CAAChB,WAAvB,EAAoC;AACvCX,MAAAA,eAAe,CAACI,MAAD,CAAf,CAAwBsB,YAAxB,CAAqCF,IAArC,CAA0CX,KAA1C;AACH;AACJ,GAtD6C,CAwD9C;;;AACAb,EAAAA,eAAe,CAACI,MAAD,CAAf,CAAwBwB,aAAxB,GACIb,YAAY,GAAGE,sBADnB;;AAEA,MAAIT,MAAM,CAACQ,MAAP,GAAgB,CAApB,EAAuB;AACnBhB,IAAAA,eAAe,CAACI,MAAD,CAAf,CAAwBmB,WAAxB,CAAoCC,IAApC,CAAyChB,MAAzC;AACH,GA7D6C,CA+D9C;;;AACA,MACIJ,MAAM,CAACE,EAAP,CAAUR,IAAV,KAAmB,EAAnB,IACAE,eAAe,CAACI,MAAD,CAAf,CAAwByB,OAAxB,KAAoC,IADpC,IAEAzB,MAAM,CAACE,EAAP,CAAUR,IAAV,IAAkB,CAHtB,EAIE;AACEE,IAAAA,eAAe,CAACI,MAAD,CAAf,CAAwByB,OAAxB,GAAkCC,SAAlC;AACH;;AAED9B,EAAAA,eAAe,CAACI,MAAD,CAAf,CAAwB2B,eAAxB,GAA0C3B,MAAM,CAACE,EAAP,CAAUmB,KAAV,CAAgB,CAAhB,CAA1C;AACAzB,EAAAA,eAAe,CAACI,MAAD,CAAf,CAAwB4B,QAAxB,GAAmC5B,MAAM,CAAC6B,SAA1C,CAzE8C,CA0E9C;;AACA7B,EAAAA,MAAM,CAACE,EAAP,CAAUR,IAAV,IAAkBoC,eAAe,CAC7B9B,MAAM,CAACe,OADsB,EAE7Bf,MAAM,CAACE,EAAP,CAAUR,IAAV,CAF6B,EAG7BM,MAAM,CAAC6B,SAHsB,CAAjC,CA3E8C,CAiF9C;;AACAf,EAAAA,GAAG,GAAGlB,eAAe,CAACI,MAAD,CAAf,CAAwBc,GAA9B;;AACA,MAAIA,GAAG,KAAK,IAAZ,EAAkB;AACdd,IAAAA,MAAM,CAACE,EAAP,CAAUT,IAAV,IAAkBO,MAAM,CAACe,OAAP,CAAegB,eAAf,CAA+BjB,GAA/B,EAAoCd,MAAM,CAACE,EAAP,CAAUT,IAAV,CAApC,CAAlB;AACH;;AAEDP,EAAAA,eAAe,CAACc,MAAD,CAAf;AACAR,EAAAA,aAAa,CAACQ,MAAD,CAAb;AACH;;AAED,SAAS8B,eAAT,CAAyBE,MAAzB,EAAiCC,IAAjC,EAAuCL,QAAvC,EAAiD;AAC7C,MAAIM,IAAJ;;AAEA,MAAIN,QAAQ,IAAI,IAAhB,EAAsB;AAClB;AACA,WAAOK,IAAP;AACH;;AACD,MAAID,MAAM,CAACG,YAAP,IAAuB,IAA3B,EAAiC;AAC7B,WAAOH,MAAM,CAACG,YAAP,CAAoBF,IAApB,EAA0BL,QAA1B,CAAP;AACH,GAFD,MAEO,IAAII,MAAM,CAACI,IAAP,IAAe,IAAnB,EAAyB;AAC5B;AACAF,IAAAA,IAAI,GAAGF,MAAM,CAACI,IAAP,CAAYR,QAAZ,CAAP;;AACA,QAAIM,IAAI,IAAID,IAAI,GAAG,EAAnB,EAAuB;AACnBA,MAAAA,IAAI,IAAI,EAAR;AACH;;AACD,QAAI,CAACC,IAAD,IAASD,IAAI,KAAK,EAAtB,EAA0B;AACtBA,MAAAA,IAAI,GAAG,CAAP;AACH;;AACD,WAAOA,IAAP;AACH,GAVM,MAUA;AACH;AACA,WAAOA,IAAP;AACH;AACJ","sourcesContent":["import { configFromISO, configFromRFC2822 } from './from-string';\nimport { configFromArray } from './from-array';\nimport { getParseRegexForToken } from '../parse/regex';\nimport { addTimeToArrayFromToken } from '../parse/token';\nimport {\n    expandFormat,\n    formatTokenFunctions,\n    formattingTokens,\n} from '../format/format';\nimport checkOverflow from './check-overflow';\nimport { YEAR, HOUR } from '../units/constants';\nimport { hooks } from '../utils/hooks';\nimport getParsingFlags from './parsing-flags';\n\n// constant that refers to the ISO standard\nhooks.ISO_8601 = function () {};\n\n// constant that refers to the RFC 2822 form\nhooks.RFC_2822 = function () {};\n\n// date from string and format string\nexport function configFromStringAndFormat(config) {\n    // TODO: Move this to another part of the creation flow to prevent circular deps\n    if (config._f === hooks.ISO_8601) {\n        configFromISO(config);\n        return;\n    }\n    if (config._f === hooks.RFC_2822) {\n        configFromRFC2822(config);\n        return;\n    }\n    config._a = [];\n    getParsingFlags(config).empty = true;\n\n    // This array is used to make a Date, either with `new Date` or `Date.UTC`\n    var string = '' + config._i,\n        i,\n        parsedInput,\n        tokens,\n        token,\n        skipped,\n        stringLength = string.length,\n        totalParsedInputLength = 0,\n        era;\n\n    tokens =\n        expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n    for (i = 0; i < tokens.length; i++) {\n        token = tokens[i];\n        parsedInput = (string.match(getParseRegexForToken(token, config)) ||\n            [])[0];\n        // console.log('token', token, 'parsedInput', parsedInput,\n        //         'regex', getParseRegexForToken(token, config));\n        if (parsedInput) {\n            skipped = string.substr(0, string.indexOf(parsedInput));\n            if (skipped.length > 0) {\n                getParsingFlags(config).unusedInput.push(skipped);\n            }\n            string = string.slice(\n                string.indexOf(parsedInput) + parsedInput.length\n            );\n            totalParsedInputLength += parsedInput.length;\n        }\n        // don't parse if it's not a known token\n        if (formatTokenFunctions[token]) {\n            if (parsedInput) {\n                getParsingFlags(config).empty = false;\n            } else {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n            addTimeToArrayFromToken(token, parsedInput, config);\n        } else if (config._strict && !parsedInput) {\n            getParsingFlags(config).unusedTokens.push(token);\n        }\n    }\n\n    // add remaining unparsed input length to the string\n    getParsingFlags(config).charsLeftOver =\n        stringLength - totalParsedInputLength;\n    if (string.length > 0) {\n        getParsingFlags(config).unusedInput.push(string);\n    }\n\n    // clear _12h flag if hour is <= 12\n    if (\n        config._a[HOUR] <= 12 &&\n        getParsingFlags(config).bigHour === true &&\n        config._a[HOUR] > 0\n    ) {\n        getParsingFlags(config).bigHour = undefined;\n    }\n\n    getParsingFlags(config).parsedDateParts = config._a.slice(0);\n    getParsingFlags(config).meridiem = config._meridiem;\n    // handle meridiem\n    config._a[HOUR] = meridiemFixWrap(\n        config._locale,\n        config._a[HOUR],\n        config._meridiem\n    );\n\n    // handle era\n    era = getParsingFlags(config).era;\n    if (era !== null) {\n        config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);\n    }\n\n    configFromArray(config);\n    checkOverflow(config);\n}\n\nfunction meridiemFixWrap(locale, hour, meridiem) {\n    var isPm;\n\n    if (meridiem == null) {\n        // nothing to do\n        return hour;\n    }\n    if (locale.meridiemHour != null) {\n        return locale.meridiemHour(hour, meridiem);\n    } else if (locale.isPM != null) {\n        // Fallback\n        isPm = locale.isPM(meridiem);\n        if (isPm && hour < 12) {\n            hour += 12;\n        }\n        if (!isPm && hour === 12) {\n            hour = 0;\n        }\n        return hour;\n    } else {\n        // this is not supposed to happen\n        return hour;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}